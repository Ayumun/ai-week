---
description: "GitHub Issueのタスクグループを実行するコマンド。ARGUMENTS: Issue番号（必須、#123形式）、タスクグループ番号（省略可、例：1.1 1.2 1.3。省略時はIssue本文から未完了タスクを自動取得して全実行）"
allowed-tools: Task, Read, Write, Edit, MultiEdit, Bash, Grep, Glob, WebFetch, mcp__github__*, mcp__serena__*
---

# タスク実行コマンド

## あなたの役割
あなたは開発チームの**タスク実行マネージャー**です。以下の責務を持っています：
- 指定された**複数のタスクグループを順番に自動実行**（task-executerサブエージェントを呼び出し）
- **品質保証（QA）が合格するまで自動的にループして継続実行**
- 品質保証とレビューの自動化
- **1つのタスクグループのQA合格後、次のタスクグループへ自動的に進行**
- **各サブエージェント完了後の報告を明確に表示し、進捗をユーザーに伝える**

**⚠️ 最重要事項**:
- **各フェーズ（executer/reviewer/qa）完了後、完了報告を表示した直後、ユーザーの応答を待たずに即座に次のフェーズを開始してください**
- **絶対に**完了報告の表示だけで処理を止めてはいけません
- executer → reviewer → qa の流れを**途切れることなく自動的に**進めてください
- **1つのタスクグループのQA合格後、次のタスクグループのexecuterフェーズを即座に開始してください**
- ユーザーからの確認や追加指示を待つことは**禁止**されています（全タスクグループ完了まで）

## 重要：サブエージェント完了報告の表示方法

各サブエージェント（task-executer、task-reviewer、task-qa、task-modification-analyzer）を呼び出した後：
1. エージェントが生成した最終メッセージ（完了報告）を取得
2. その完了報告をそのまま出力して、ユーザーに見せる
3. **単に「Done」だけでなく、サブエージェントの詳細な報告内容を表示すること**

## タスク実行の指示

ユーザーから「$ARGUMENTS」を使用したタスクグループ実行を依頼されました。

### 入力の解析
$ARGUMENTSには以下が含まれます：
- **Issue番号**（必須、例: `#123`、`123`）
- **タスクグループ番号**（省略可、例: `1.1`、`1.1 1.2 1.3`、`2.1 2.2`）

Issue番号が指定されていない場合は、ユーザーに入力を要求します。

#### タスクグループの決定方法
1. **タスクグループ番号が指定された場合**: 指定された番号を順番に実行
2. **タスクグループ番号が省略された場合**: GitHub IssueをMCPで取得し、本文から**未完了（チェックなし `- [ ]`）のタスクグループを依存関係順に自動抽出**して全実行
   - `mcp__github__get_issue` でIssue本文を取得
   - `- [ ] **X.Y タスクグループ名**` 形式の未チェック行を抽出
   - 各タスクグループの `**依存関係**:` を読み取り、依存が解決済み（完了済み `- [x]`）のものから順に実行
   - 既に完了済み（`- [x]`）のタスクグループはスキップ

### ブランチ準備（実装開始前に必ず実行）

1. `issue/{Issue番号}` ブランチにチェックアウト（`/spec-create` で作成済み）
2. リモートの最新を取得（`git pull origin issue/{Issue番号}`）
3. **以降のすべての実装・コミットはこのブランチ上で行う**

**⚠️ 絶対に main ブランチ上で実装してはいけない**

## 処理フロー

このコマンドは指定された**すべてのタスクグループを順番に実行**し、全タスクグループのQA合格後にコマンドを終了します。

### タスクグループ連続実行フロー

```
タスクグループ 1.1 開始
  ├─ executer → reviewer → qa（品質保証ループ）
  └─ QA合格 ✓
      ↓ 自動的に次へ（待機禁止）
タスクグループ 1.2 開始
  ├─ executer → reviewer → qa（品質保証ループ）
  └─ QA合格 ✓
      ↓ 自動的に次へ（待機禁止）
タスクグループ 1.3 開始
  ├─ executer → reviewer → qa（品質保証ループ）
  └─ QA合格 ✓
      ↓
全タスクグループ完了 → 追加指示待ち状態
```

### 各タスクグループの品質保証ループ ⟲

1. **task-executer**: 実装フェーズ
   - 指定タスクグループ用にtask-executerサブエージェントを呼び出し
   - 完了後、完了報告を表示
   - → **完了報告表示の直後、即座にreviewerフェーズへ進む（待機禁止）**

2. **task-reviewer**: レビューフェーズ
   - 実装内容をレビュー
   - task-executerサブエージェント完了後に開始
   - 完了後、完了報告を表示
   - **問題発見時**: → **完了報告表示の直後、即座にexecuterフェーズに戻る（待機禁止）** ⟲
   - **問題なし**: → **完了報告表示の直後、即座にqaフェーズへ進む（待機禁止）**

3. **task-qa**: 品質保証フェーズ
   - 受け入れ条件に基づくテスト実行
   - task-reviewerサブエージェント完了後に開始
   - 完了後、完了報告を表示
   - **テスト失敗時**: → **完了報告表示の直後、即座にexecuterフェーズに戻る（待機禁止）** ⟲
   - **全テスト合格**: → **次のタスクグループへ自動進行（待機禁止）**。残りがなければ追加指示待ち状態へ

**品質保証ループ終了** ✓ → **次のタスクグループへ**

### 追加指示待ち状態

**全タスクグループの**QA合格後、タスク完了を報告し、**追加指示待ち状態**に入ります。コマンドはまだ終了しません。

**注意**: GitHub Issueのチェックボックス更新は自動では行いません。必要な場合はユーザーが明示的に指示してください。

**ユーザーへの案内**:
```
全タスクグループ（1.1, 1.2, 1.3）の実装が完了しました。

追加の修正や改善がある場合は指示してください。
完了する場合は「終了」または「完了」と入力してください。
```

## 追加修正対応

ユーザーから追加の修正や改善の指示があった場合、以下のフローで対応します：

**フロー**:
```
追加指示待ち状態
    ↓
ユーザーから追加の修正指示
    ↓
task-modification-analyzer を呼び出し
    ↓
分析結果・提案を表示
（ドキュメント修正必要性、修正規模、再レビュー/再QA必要性を判定）
    ↓
ユーザーの承諾を待つ
    ↓（承諾）
analyzerの推奨に基づいて実行
    ↓
再度、追加指示待ち状態へ
```

**コマンド終了条件**:
- ユーザーが「終了」「完了」「done」などと入力した場合
- プッシュ前にプロジェクト内のスクリーンショット（`*.png`, `*.jpeg`）を削除（テストレポート等の `.md` ファイルは残す）
- `issue/{Issue番号}` ブランチをリモートにプッシュ（PRは `/spec-create` で作成済みなので自動的に更新される）
- コマンドを終了し、完了報告とPR URLを表示

**実行パターン**:

**パターンA: executer単独**（小規模・単純な修正）
- 対象: 1-2ファイルの軽微な修正、文言修正、スタイル調整など
- 判定: 再レビュー/再QA不要
- フロー: `task-executer` のみ実行

**パターンB: フルパイプライン**（中規模以上の修正）
- 対象: ロジック変更、新機能追加、複数コンポーネントに影響
- 判定: 再レビュー/再QA必要
- フロー: `task-executer` → `task-reviewer` → `task-qa`

## 実行例

```bash
# Issue内の未完了タスクグループを全自動実行（推奨）
/task-exec #123

# 特定のタスクグループのみ実行
/task-exec #123 1.1

# 複数タスクグループを指定して連続自動実行
/task-exec #123 1.1 1.2 1.3

# Issue番号のみ（#なし）
/task-exec 123
```

## 内部処理

このコマンドは`Task`ツールを使用して、専用サブエージェントを組み合わせて実行します：

### 1. 実装フェーズ（task-executer）
- 要件定義・設計書に基づいた高品質な実装を実行
- **完了時**: task-executerが生成した「## 🔨 実装フェーズ完了」で始まる完了報告を取得し、そのまま出力してユーザーに表示する
- **重要**: このフェーズはreviewer/qaで問題が見つかった場合、自動的に再実行されます
- **完了時の処理**:
  1. 完了報告を表示
  2. 完了報告を表示した**直後**、**ユーザーの応答を待たずに即座に**task-reviewerサブエージェントを呼び出してreviewerフェーズを開始
  3. **絶対に**ユーザーからの確認や追加指示を待ってはいけない

### 2. レビューフェーズ（task-reviewer）
- task-executerサブエージェント完了後に開始
- 要件定義・設計との整合性確認
- 仮実装の検出と後続タスクの確認
- **問題発見時**: task-reviewerが問題を報告
  1. 完了報告に問題点を記載して表示
  2. **自動的にexecuterフェーズに戻る**（task-executerサブエージェントを再呼び出し）
  3. 修正後、再度reviewerフェーズを実行
  4. 問題がなくなるまで繰り返す
- **完了時（問題なし）**:
  1. task-reviewerが生成した完了報告を表示
  2. 完了報告を表示した**直後**、**ユーザーの応答を待たずに即座に**task-qaサブエージェントを呼び出してqaフェーズを開始

### 3. 品質保証フェーズ（task-qa）
- task-reviewerサブエージェント完了後に開始
- 受け入れ条件に基づく動作確認
- 画面: Playwright MCP、API: curl、スクリプト: 実行確認
- **テスト失敗時**: task-qaがテスト失敗を報告
  1. 完了報告に失敗内容を記載して表示
  2. **自動的にexecuterフェーズに戻る**（task-executerサブエージェントを再呼び出し）
  3. 修正後、再度reviewerフェーズ → qaフェーズを実行
  4. すべてのテストが合格するまで繰り返す
- **完了時（全テスト合格）**:
  1. task-qaが生成した完了報告を表示
  2. **次のタスクグループが残っている場合**: 即座に次のタスクグループのexecuterフェーズを開始（待機禁止）
  3. **全タスクグループ完了の場合**: 追加指示待ち状態へ

### 4. 追加修正対応フェーズ（task-modification-analyzer）（オプション）
- コマンド完了後、ユーザーから追加の修正指示があった場合に開始
- `Task`ツールで`subagent_type='task-modification-analyzer'`を指定してサブエージェントを呼び出し
- **分析内容**:
  - ユーザー指示の解析（修正カテゴリ、対象の特定）
  - 既存ドキュメント（requirements.md、design.md、GitHub Issue）の確認
  - 修正規模・複雑度の判定（小規模/中規模/大規模）
  - 再レビュー/再QA必要性の判定
  - 修正方針の提案
- **完了時**:
  1. task-modification-analyzerが生成した「## 📊 修正分析完了」で始まる分析レポートを表示
  2. **ユーザーの承諾を待つ**（自動進行しない）
  3. 承諾後、推奨パイプラインに従って実装を開始

## 注意事項

- GitHub Issueのタスク一覧は特定のフォーマットに従っている必要があります
- Issue番号とタスクグループ番号の両方が必須です
- **GitHub Issueの更新（チェックボックス）は自動では行いません** - 必要な場合は明示的に指示してください
- 追加指示への対応: コマンド完了後にユーザーから追加の修正や改善の指示があった場合、task-modification-analyzerサブエージェントで修正規模と品質保証の必要性を判定します

## コミットルールの遵守（必須）

**重要**: 実装フェーズでコミットを行う際は、**必ず** [コミットルール](../../docs/steering/commit-rules.md) を参照し、以下を厳守すること：

- **コミット分割**: 異なる目的・種類の変更は必ず別々のコミットに分割
- **コミット粒度**: 1コミット1論理的変更、100行程度を目安
- **コミットメッセージ**: プレフィックス（feat/fix/docs/refactor/test/chore）+ 日本語で明確な説明
- **プッシュ前チェック（必須）**: プッシュ前に `npm run prepush` を**必ず**実行し、全チェック（ESLint + Stylelint）を通過してからプッシュすること。`package.json` はリポジトリに常に存在する前提とする

**禁止事項**:
- まとめコミット
- 複数目的の混在コミット
- コミット粒度の過剰肥大化
- `npm run prepush` 未実行でのプッシュ（例外なし）
